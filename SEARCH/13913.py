# 숨바꼭질 4

"""
(시간 초과)
수빈이 위치부터 bfs 탐색 - 100001 크기의 graph에서 탐색 
>> 메모리 초과나면 이 로직 아닌걸로 수정

0. 탐색 전, 수빈이 위치 == 동생위치면, 그냥 0과 수빈 위치 출력 후 종료
1. bfs. 수빈이 위치부터 탐색
- 처음 큐에는 수빈이 위치를 넣고, 탐색 시작
    - 세 가지 경우를 모두 계산함 (뒤로 한칸, 앞 한칸, 앞으로 2배)
    - 이동할 위치가 범위 내에 있을 때
    - 값이 0이면 큐에 추가하고 방문 처리
    - 값이 동생(-100)이면 부모의 방문값 리턴 (이제 이 값으로 역추적)
2. 역추적해서 경로 찾기 (동생 위치, 가장 짧은 초를 가지고 역추적)
    - 동생 위치부터 시작해서 이제 수빈을 찾음
    - 이때 2배 대신 나누기 2로, 그리고 현재 값이 홀수라면 나누기 사용X (+1, -1, *2 순으로)
    - bfs
        - 처음 큐에 동생 번호 저장,
        - 이동할 위치가 범위 내에 있을 때, 값이 0이면 큐에 추가하고 방문 처리
        - 값이 수빈(-100)이면 현재 해당하는 배열 출력 후 리턴
        - 이때 path라는 배열로 경로 관리 
            - 처음 동생 위치부터 저장, bfs 한 depth마다 각각 따로 배열을 저장
            - 즉, 이전 배열 + 자신 추가
            1. 현재 path에 있는 모든 배열에서 가장 끝원소가 갈 수 있는 곳을 모두 추가한 배열 생성 (ex. 2개 추가 가능하다면 2개 배열 생성)
            2. 방금 생성된 배열들을 path에 덮어씌운다 (이전 것들은 필요 없음)
            3. 배열의 길이 검사했을 때, 배열 길이가 sec+1이고, 끝원소가 수빈이 위치인 배열이 있으면 리턴해서 거꾸로 출력

"""

"""
(메모리 초과)
그냥 bfs 한번 돌면서 메모리 많이 쓰는 버전으로 가보자 
1. bfs 탐색하며, 동생 찾을 때 까지 최단 경로 다 저장하면서 반복
- 처음 큐에는 수빈이 위치를 넣고, 탐색 시작
    - 세 가지 경우를 모두 계산함 (뒤로 한칸, 앞 한칸, 앞으로 2배)
    - 이동할 위치가 범위 내에 있을 때
        - 값이 0이면 큐에 추가하고, 방문 처리하고, path[n]에 부모의 경로 + 자신을 추가한 경로 저장
        - 값이 동생(-100)이면 부모의 방문값(최단 시간)과 경로(부모 경로 + 자신 추가한) 리턴

"""

"""
(메모리 초과 해결 로직) _ 딕셔너리로 이전 경로 저장 
>> 딕셔너리로 전 경로를 저장하면서 bfs를 하면, 메모리 초과를 방지할 수 있다!
예를 들어 5 -> 6 -> 12 -> 24 -> 23 -> 46 와 같이 움직였다면 dict = { 46 : 23, 23 : 24, 24 : 12, 12 : 6, 6 : 5 } 와 같이 저장하여 경로를 파악

-> 이거 시간, 공간적으로도 매우 효율적이고 좋음!!

"""

import sys
from collections import deque

input = sys.stdin.readline
graph = [0] * 100001
N, K = map(int, input().split())
dic = {}
def bfs():
    que = deque([N])
    
    while que : 
        cur = que.popleft()
        for i in range(3) :
            if i == 0: n = cur -1
            elif i == 1 : n = cur +1
            else : n = cur * 2

            if 0 <= n < 100001 : 
                if graph[n] == -100 : 
                    dic[n] = cur
                    return graph[cur]
                elif graph[n] == 0 : 
                    graph[n] = graph[cur] + 1
                    que.append(n)
                    dic[n] = cur # cur의 부모는 n이다
if N == K : 
    print(0)
    print(N)  
    exit()

graph[N] = 1
graph[K] = -100
sec = bfs()
print(sec)

parent = K
child = -1
path = []
while True :
    child = dic[parent]
    path.append(parent)
    parent = child
    if child == N : 
        path.append(child)
        break

path = path[::-1]
print(*path)