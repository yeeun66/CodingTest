# 로봇 청소기
# 로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성

# 로봇 청소기가 있는 방은 N x M 크기의 직사각형으로 나타낼 수 있으며, 각각의 칸은 벽 또는 빈 칸이다. 
# 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 (r, c)로 나타낼 수 있다. >> (0,0) 부터 (n-1, m-1)까지
# 처음에 빈 칸은 전부 청소되지 않은 상태이다.
# 로봇 청소기는 다음과 같이 작동한다.
    # 1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.
    # 2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,
        # 1. 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
        # 2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
    # 3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우,
        # 1. 반시계 방향으로 90도 회전한다.
        # 2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
        # 3. 1번으로 돌아간다.

# 입력: 
# 첫째 줄에 방크기 N, M이 입력된다
# 둘째 줄에 로봇 청소기 좌표 r, c와 청소기가 바라보는 방향 d가 입력된다 (d가 0~3일 때, 각각 북동남서)
# 셋째 줄부터 N x M개의 값이 한줄에 M개씩 입력된다
    # 이 값이 0인 경우 청소되지 않은 빈칸이고 1인 경우 벽이다. 

# 출력: 로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수를 출력한다.

# 방법: 
# 현재 로봇청소기 위치(r,c)를 큐에 넣고 탐색시작
# bfs 기반 탐색 (상하좌우 대신, 북동남서)
    # 큐 엠티까지 아래를 반복
        # 현재 위치의 값을 2로 바꾸고 큐에서 꺼낸다
        # 현재 위치에서 북동남서 탐색
        # 1. 주변 4군데에 빈칸이 없으면
            # 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면(4가지 케이스 모두 조건으로) 한칸 후진한 좌표를 큐에 넣는다
            # 한칸 후진했을 때 벽(=1)이라면 작동 멈춘다.
            # 후진하고 방향 다시 복원 시켜줘야 함!! 
        # 2. 주변 4군데에 빈칸이 있으면
            # 반시계 방향으로 90도 회전한다
            # 바라보는 방향 기준으로 앞쪽칸이 빈칸인 경우 전진한 좌표를 큐에 넣는다
# 탐색이 끝나면 2의 갯수를 출력한다. 

import sys
from collections import deque
input = sys.stdin.readline

# 북동남서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

N, M = map(int, input().split())
r, c, d = map(int, input().split())
graph = []
for _ in range(N) :
    graph.append(list(map(int, input().split())))

queue = deque()
queue.append((r, c))
while queue : 
    x, y = queue.popleft()
    graph[x][y] = 2
    search = False
    for i in range(4) :
        nx = x + dx[i]
        ny = y + dy[i]
        if 0 <= nx < N and 0 <= ny < M and graph[nx][ny] == 0 : 
            search = True
            break
    if not search : # 주변에 빈칸이 없으면
        tmp = d
        d = (d + 2) % 4 # 후진
        nx = x + dx[d]
        ny = y + dy[d]
        if 0 <= nx < N and 0 <= ny < M and graph[nx][ny] != 1 : 
            queue.append((nx, ny)) # 후진 가능하면 큐에 넣어
            d = tmp # 후진만 한거니까 원래 방향 복원 (이거 하니까 맞음)
        else : break
    else : # 주변에 빈칸이 있으면 
        for _ in range(4) :
            d = (d + 3) % 4 # 반시계 90도
            nx = x + dx[d]
            ny = y + dy[d] 
            if 0 <= nx < N and 0 <= ny < M :
                if graph[nx][ny] == 0: 
                    queue.append((nx, ny)) # 앞쪽에 빈칸이 있으면 큐에 넣어
                    break

cnt = 0
for i in range(N) :
    cnt += graph[i].count(2)
print(cnt)