# 센서
# 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.
# 각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 '연결된 구간'으로 나타나게 된다. 
# N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

# 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 
# 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 
# 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.

# 방법: 오름차순 정렬 후, k개로 분리할 때 간격이 가장 먼곳을 분리하는 아이디어
# 1. 오름차순 정렬한 배열에서 간격이 큰 순으로 k개의 구간으로 나눈다
    # gap 배열에 각 숫자들의 차이를 순서대로 넣어 놓는다
    # 차이가 큰 순서대로 k개 만큼만 간격 표시 해둔다 (즉, k-1개)
        # gap 배열에서 크기가 큰 순서대로 임시 배열 index에 인덱스 번호를 추가한다
# 2. 각 나눠진 구간 마다 (즉 k번 만큼) (가장 큰 값 - 가장 작은 값)을 결과에 더한다.
    # 아래를 index 배열의 끝까지 반복한다 (현재 위치를 나타내는 변수 cur을 0으로 초기화 한다)
        # 배열에서 하나를 꺼낸다 
        # 결과값 += arr[방금꺼낸인덱스] - arr[cur] 한 후,
        # cur = 방금꺼낸인덱스 + 1로 수정

N = int(input())
K = int(input())
arr = list(map(int, input().split()))
arr.sort()

if N == 1 : 
    print(0)
    exit()

gap = []
for i in range(N-1) :
    gap.append(arr[i+1]- arr[i])

mx = max(gap)
index = []
cnt = 0
while True :
    for i in range(N-1) :
        if cnt >= K-1 : break
        if gap[i] == mx :
            index.append(i)
            cnt += 1
            gap[i] = -1
    if cnt >= K-1 : break
    mx = max(gap)

index.sort()
index.append(N-1)
result = 0
cur = 0
for a in index :
    result += (arr[a] - arr[cur])
    cur = a + 1

print(result)