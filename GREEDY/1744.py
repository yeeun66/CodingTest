# 수 묶기
# 길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 
# 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 
# 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.
# 예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2*3)+(4*5) = 27이 되어 최대가 된다.
# 수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.
# 수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.

# 방법: 
# 1. 입력 받은 수열에서 0이상과 0이하로 배열을 나눈 후 오름차순 정렬 (0이 있다면 이건 음수쪽에 넣기) # 둘 다 데크에 저장
# 2. 0 이상 배열에서는 뒤쪽 부터 2개씩 pop하며 곱하여 결과에 더한다
    # 배열에 1개가 이하로 남으면 반복 종료
    # 반복 종료 후 남은 하나가 있다면 그대로 더한다
# 3. 0 이하 배열에는 앞쪽 부터 2개씩 pop하며 곱하여 결과에 더한다
    # 배열에 2개 이하로 남으면 반복 종료
    # 반복 종료 후 남은 것이 2개라면 두개 곱한 후 최종적으로 더해줌
    # 남은 것이 1개라면 그냥 최종에 더해줌

from collections import deque

N = int(input())
pos = []
neg = []

for _ in range(N) :
    x = int(input())
    if x > 0 : pos.append(x)
    else : neg.append(x)
pos.sort()
neg.sort()

neg = deque(neg)
result = 0
while len(pos) > 1 :
    m1 = pos.pop()
    m2 = pos.pop()
    if m2 == 1 : 
        result += m1 + m2 # 곱하기 1인 경우는 곱하는 것 보다 더하는게 더 큰 결과임
    else : result += m1 * m2

if pos : result += pos[0]

while len(neg) > 2 : 
    m1 = neg.popleft()
    m2 = neg.popleft()
    result += m1 * m2

if len(neg) == 2 : result += neg[0] * neg[1]
elif len(neg) == 1 : result += neg[0]

print(result)