# 치킨 배달
# 크기가 N×N인 도시가 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 
# 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열을 의미한다. r과 c는 1부터 시작한다.
# 치킨 거리는 집과 가장 '가까운' 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 
# 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.
# 임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.

# 0은 빈 칸, 1은 집, 2는 치킨집이다.
# 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 
# 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는 치킨집의 개수는 최대 M개라는 사실을 알아내었다.
# 도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 
# 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성

# 입력
# 첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다
# 아래는 도시 정보
# 출력
# 첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.

# 방법
# 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같으니까
# 치킨집의 개수를 x라고 할 때 x개 중에 M개를 골라서 치킨 거리가 가장 최소가 되도록 하는 값을 브루트포스로 다 찾는다면
    # 최대 13C6 (=1716) 이니까 O(n^2) 시간 안에 쌉가능

# 1. 치킨집 x개 중에 M개를 뽑는 모든 경우의 수에 대하여 2차원 배열을 다 탐색하며 치킨 거리(street)를 업데이트 한다 
    # 치킨집, 즉 값이 '2'인 모든 좌표를 치킨집 배열에 저장한 후, 거기서 좌표를 조합으로 뽑음
    # 이 때 조합에서 뽑힌 치킨 집은 '3'으로 표시하고, 탐색이 끝나면 해당 좌표를 다시 '2'로 돌려 놓는다
# 2. 치킨 거리 업데이트 함수 -> 집 '1'에 대하여 각각 가장 가가운 치킨 집 '3' 탐색
    # 집의 좌표도 미리 집 배열에 저장해둔다
    # 좌표에서 하나씩 꺼내면서 상하좌우로 bfs 처럼 치킨집 '3'을 탐색한다
        # 치킨집을 발견하면 해당 좌표와 주어진 식으로 거리 계산한 후, 임시 치킨 거리(temp)에 더한다.
        # 그러고는 해당 집 탐색을 끝낸다
    # 최종 임시 치킨 거리와 현재 치킨 거리 중 최소 값을 업데이트 한다

# 메모리 초과 해결하기~ 
# bfs로 다 탐색하는게 아니라 집 하나에 대하여 가장 가까운 치킨 집 하나만 찾아서 거리 계산하면 되니까
    # 현재 선택된 치킨집 배열들을 하나씩 비교하며 최소값 찾으면 됨!!
    
import sys
from itertools import combinations
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def find_bhc(city) :
    tmp = 0
    for h in house :
        a, b = h
        temp = float('inf')
        for cx, cy in cmb :
            temp = min(temp, abs(a-cx) + abs(b-cy))
        tmp += temp
    
    return tmp

N, M = map(int, input().split())
city = []
bhc = []
house = []
street = float('inf')
for _ in range(N) : city.append(list(map(int, input().split())))

for i in range(N) :
    for j in range(N) :
        if city[i][j] == 2 : bhc.append((i, j))
        elif city[i][j] == 1 : house.append((i, j))

for cmb in combinations(bhc, M) :
    street = min(street, find_bhc(cmb))

print(street)