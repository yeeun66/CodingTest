# 크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오등큰수 NGF(i)를 구하려고 한다.

# Ai가 수열 A에서 등장한 횟수를 F(Ai)라고 했을 때, 
# Ai의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(Ai)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 
# 그러한 수가 없는 경우에 오등큰수는 -1이다.

# 예를 들어, A = [1, 1, 2, 3, 4, 2, 1]인 경우 
# F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. 
# A1의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. 
# A3의 경우에는 A7이 오른쪽에 있으면서 F(A3=2) < F(A7=1) 이기 때문에, NGF(3) = 1이다. 
# NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.

# 총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력한다.

# 예를 들어 A6(=2)일 때, 현재 스택에는 [1, 1, 2, 3, 4] 상태 <= 이때 스택에는 원소 값이 아닌 인덱스가 들어가 있음
# 이 때, 3과 4는 A6(=2)를 오등큰수로 함
# A7(=1)일 때, 현재 스택에는 [1, 1, 2, 2] 상태
# 이 때 2와 2는 1을 오큰수로 가짐

# 로직 (현재의 값을 오등큰수로 갖는 앞 원소들 찾기)
# 1. 원소 등장 횟수 세서 F에 넣어두기
# 2. 반복문 돌면서, 현재 위치와 스택의 원소를 비교 
# (원리: 현재 인덱스의 원소를 오등큰수로 하는 숫자 지정. 그 숫자는 스택에 있겠지)
# 스택에 무언가 있고, 스택의 top 원소의 갯수가 현재 인덱스 원소의 갯수보다 작을 때 반복
    # 반복문에 들어왔다면, 그 스택의 top원소는 현재 인덱스 원소를 오등큰수로 가짐
    # 따라서 output[그_인덱스를 pop()하고] = A[i]
# 스택에 현재 인덱스 추가

import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

F = [0] * 1000001
stk = [] # 인덱스를 관리
output = [-1] * N # 초기값 -1

for a in A : F[a] += 1

for i in range (N):
    while stk and F[A[stk[-1]]] < F[A[i]] :
        output[stk.pop()] = A[i]
    stk.append(i)

print(*output)